\chapter{Аналитическая часть}

В данном разделе рассматриваются существующие алгоритмы построения реалистичных изображений. Так же, обосновывается выбор реализуемого алгоритма и указывается список ограничений, в рамках которых будет работать разрабатываемое ПО.

\section{Формализация объектов синтезируемой сцены}
Сцена состоит из следующих объектов:
\begin{itemize}
    \item источников света:
    \begin{itemize}
        \item источник рассеянного света - задается интенсивностью. Используется для освещения всей сцены;
        \item источник направленного света - задается вектором направленности и интенсивностью. Предполагается, что такой источник расположен в бесконечности;
        \item точечный источник света - задается положением в пространстве и интенсивностью;
    \end{itemize}   
    \item фрактальной поверхности.
\end{itemize}

Существует несколько способов представления фрактальной поверхности. На пример, можно представлять поверхность аналитически или же преобразовать ее в полигональную поверхность и представить в виде списка граней и т.д.. Представление поверхности в виде аналитического выражения является более предпочтительным в данной работе, так как позволяет синтезировать сцену сколь угодно высокой точности, в отличие от остальных способов представления поверхностей.

\section{Описание алгоритмов удаления невидимых линий и поверхностей}

\subsection {Некоторые теоретические сведения}

Прежде чем описывать алгоритмы, нужно дать некоторые определения, которые будут использованы в данном разделе.

Алгоритмы удаления невидимых линий и поверхностей служат для определения линий ребер, поверхностей, которые видимы или невидимы для наблюдателя, находящегося в заданной точке пространства \cite{rogers}.

Решать задачу можно в:
\begin{itemize}
	\item объектном пространстве - мировая системе координат, высокая точность. Обобщенный подход, основанный на анализе пространства объектов, предполагает попарное сравнение положения всех объектов по отношению к наблюдателю.
	\item пространстве изображений - в экранных координатах, системе координат, связанной с тем устройством в котором отображается результат. (Графический дисплей).
\end{itemize}

Под экранированием подразумевается загораживание одного объекта другим.

Под глубиной подразумевается значение координаты Z, направленной от зрителя, за плоскость экрана.

\subsection{Алгоритм Робертса}

Алгоритм Робертса решает задачу удаления невидимых линий. Работает в объектном пространстве. Данный алгоритм работает исключительно с выпуклыми телами. Если тело изначально является не выпуклым, то нужно его разбить на выпуклые составляющие. Алгоритм целиком основан на математических предпосылках \cite{rogers}.

Из-за сложности математических вычислений, используемых в данном алгоритме, а так же из-за дополнительных затраты ресурсов на вычисление матриц данный алгоритм является довольно медленным.

\subsection{Алгоритм Варнака}

Алгоритм Варнака \cite{rogers,shykin,bayackovskiy} позволяет определить, какие грани или части граней объектов сцены видимы, а какие заслонены гранями других объектов. Так же как и в алгоритме Робертса анализ видимости происходит в пространстве изображения. В качестве граней обычно выступают выпуклые многоугольники, алгоритмы работы с ними эффективнее, чем с произвольными многоугольниками. Окно, в котором необходимо отобразить сцену, должно быть прямоугольным. Алгоритм работает рекурсивно, на каждом шаге анализируется видимость граней и, если нельзя легко определить видимость, окно делится на 4 части и анализ повторяется отдельно для каждой из частей (см. рис. \ref{img:Warnock_1}).

\imgs{Warnock_1}{ht!}{0.7}{Пример разбиения Алгоритмом Варнока}

Так как данный алгоритм основывается на рекурсивном разбиении экрана, в зависимости от расположения объектов это может вызвать, как положительной, так и отрицательный эффект. Чем меньше пересечений объектов, тем быстрее алгоритм завершит свою работу.

\subsection{Алгоритм Z--буфера}

Алгоритм Z--буфера \cite{rogers,shykin} позволяет определить, какие пикселы граней сцены видимы, а какие заслонены гранями других объектов. Z--буфер -– это двухмерный массив, его размеры равны размерам окна, таким образом, каждому пикселу окна, соответствует ячейка Z-буфера. В этой ячейке хранится значение глубины пиксела (см. рис. \ref{img:z-buff}). Перед растеризацией сцены Z--буфер заполняется значением, соответствующим максимальной глубине. В случае, когда глубина характеризуется значением w,
максимальной глубине соответствует нулевое значение. Анализ видимости происходит при растеризации граней, для каждого пиксела рассчитывается глубина и сравнивается со значением в Z--буфере, если рисуемый пиксел ближе (его \texttt{w} больше значения в Z--буфере), то пиксел рисуется, а значение
в Z--буфере заменяется его глубиной. Если пиксел дальше, то пиксел не рисуется и Z--буфер не изменяется, текущий пиксел дальше того, что нарисован ранее, а значит невидим. 

\imgs{z-buff}{h!}{0.7}{Пример работы алгоритма Z--буфера}

К недостаткам алгоритма следует отнести довольно большие объемы требуемой памяти, а также имеются другие недостатки, которые состоят в трудоемкости устранения лестничного эффекта и трудности реализации эффектов прозрачности.

\subsection{Алгоритм прямой трассировки лучей}

Основная идея алгоритма прямой трассировки лучей \cite{shykin} состоит в том, что наблюдатель видит объекты благодаря световым лучам, испускаемым некоторым источником, которые падают на объект, отражаются, преломляются или проходят сквозь него и в результате достигают зрителя.

Основным недостатком алгоритма является излишне большое число рассматриваемых лучей, приводящее к существенным затратам вычислительных мощностей, так как лишь малая часть лучей достигает точки наблюдения. Данный алгоритм подходит для генерации статических сцен и моделирования
зеркального отражения, а так же других оптических эффектов \cite{traceproblem}.

\subsection{Алгоритм обратной трассировки лучей}

Алгоритм обратной трассировки лучей отслеживает лучи в обратном направлении (от наблюдателя к объекту) \cite{shykin}. Такой подход призван повысить эффективность алгоритма в сравнении с алгоритмом прямой трассировки лучей. Обратная трассировка позволяет работать с несколькими источниками света, передавать множество разных оптических явлений \cite{snizko}.

Пример работы данного алгоритма приведен на Рисунке \ref{img:trace_scheme}.

\imgs{trace_scheme}{h!}{0.7}{Пример работы алгоритма обратной трассировки лучей}

Считается, что наблюдатель расположен на положительной полуоси z в бесконечности, поэтому все световые лучи параллельны оси z. В ходе работы испускаются лучи от наблюдателя и ищутся пересечения луча и всех объектов сцены \cite{bayackovskiy}. В результате пересечение с максимальным значением z является видимой частью поверхности и атрибуты данного объекта используются для определения характеристик пикселя, через центр которого проходит данный световой луч. 

Для расчета эффектов освещения сцены проводятся вторичные лучи от точек пересечения ко всем источникам света. Если на пути этих лучей встречается непрозрачное тело, значит, данная точка находится в тени.

Несмотря на более высокую эффективность алгоритма в сравнении с прямой трассировкой лучей, данный алгоритм считается достаточно медленным, так как в нем происходит точный расчет сложных аналитических выражений для нахождения пересечения с рассматриваемыми объектами.

\subsection{Алгоритм Ray Marching}

У алгоритмов прямой и обратной трассировки имеется ряд преимуществ, а именно:
\begin{itemize}
    \item возможность обрабатывать множество различных объектов, имеющих сложные формы;
    \item возможность строить реалистичные тени и отраения объектов.
\end{itemize}

Тем не менее, данные алгоритмы требуют задания уравнений поверхности для каждого из рассматриваемых объектов . 

В случаях, когда некоторая потеря точности вычислений является некритичной, можно воспользоваться алгоритмом \texttt{Ray Marching}'га. 

Основная идея данного алгоритма состоит в том, что, вместо аналитического вычисления точки пересечения луча и рассматриваемого объекта, мы «шагаем» точкой вдоль луча, пока не найдём точку пересечения с объектом.

На Рисунке \ref{img:ray_marching_simple} приведен пример работы данного алгоритма.

\imgs{ray_marching_simple}{ht!}{0.6}{Пример работы алгоритма \texttt{Ray Marching}}

Функция \texttt{raymarching}-а с фиксированным интервалом, такая например, как показана на Рисунке \ref{img:ray_marching_simple}, вполне достаточна для множества областей применения, например, объёмных и прозрачных поверхностей. 

Тем не менее, для непрозрачных объектов можно ввести ещё одну оптимизацию. Для этой оптимизации требуется использование \texttt{SDF}.

На Рисунке \ref{img:ray_marching} приведен пример работы данного оптимизации алгоритма.

\imgs{ray_marching}{ht!}{0.6}{Пример работы алгоритма \texttt{Ray Marching} с \texttt{SDF}}

Из Рисунка \ref{img:ray_marching} видно, что такая оптимизация позволяет уменьшить количество «шагов», позволяя динамически изменять размер «шага».

\section{Описание алгоритмов построения теней}

Для создания реалистичного изображения в компьютерной графике применяются различные алгоритмы освещения.

Модель освещения предназначена для расчета интенсивности отраженного к наблюдателю света в каждой точке изображения.

Модель освещения может быть:
\begin{itemize}
    \item локальной - в данной модели учитывается только свет от источников и ориентация поверхности.
    \item глобальной - в данной модели, помимо составляющих локальной, учитывается еще и свет, отраженный от других поверхностей или пропущенный через них.
\end{itemize}

Локальная модель включает 3 составляющих:
\begin{enumerate}
	\item Диффузную составляющую отражения.
	\item Отражающую составляющую отражения.
	\item Рассеянное освещение.
\end{enumerate}

Выбор алгоритма построения теней напрямую зависит от выбора алгоритма отсечения невидимых ребер и поверхностей, а так же - от выбора модели освещения. 

Так в алгоритме трассировки лучей тени получаются практически без дополнительных вычислений, а в алгоритме с Z буфером, к примеру, можно получить тени, используя второй буфер, полученный подменой точки наблюдения на точку источника света. 

\section{Вывод}

Оценив все изложенные выше алгоритмы, можно сделать вывод, что для данной работы, предполагающей визуализацию реалистического изображения, учитывая тени, различные источники освещения и т.д., подходит алгоритм \texttt{Ray Marching}, так как он позволяет достичь высокой реалистичности, а также точности построенного изображения.

Данный алгоритм будет использоваться, несмотря на указанные недостатки, так как он достаточно полно отражает суть физических явлений с приемлемой потерей точности вычисления.

